# goit-algo-hw-04

Для алгоритмів сортування отримані такі результати:

unsorted array of 10 numbers 1-100
0.00032329303212463856 - sort
0.0005146288312971592 - sorted
0.003529828041791916 - insertion_sort
0.016728746937587857 - merge_sort

unsorted array of 100 numbers 1-1000
0.0073664551600813866 - sort
0.004592075012624264 - sorted
0.37321355077438056 - insertion_sort
0.3731768960133195 - merge_sort

unsorted array of 1000 numbers 1-10000
0.13178978790529072 - sort
0.12633596500381827 - sorted
44.643805132946 - insertion_sort
3.6465996720362455 - merge_sort

sorted array of 10 numbers 1-100
0.0002628129441291094 - sort
0.00045891408808529377 - sorted
0.0018807421438395977 - insertion_sort
0.015467465855181217 - merge_sort

sorted array of 100 numbers 1-1000
0.0012282920069992542 - sort
0.0017612490337342024 - sorted
0.020703927148133516 - insertion_sort
0.30340688908472657 - merge_sort

sorted array of 1000 numbers 1-10000
0.016259569907560945 - sort
0.018963938113301992 - sorted
0.24056824808940291 - insertion_sort
3.093245015013963 - merge_sort

Алгоритм sort() при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 22,81 разів більше часу для виконання, що відповідає приблизно O(10*log10), при збільшенні кількості елементів масиву з 100 до 1000 потребує в 17,95 разів більше часу для виконання, що менше за O(10*log10).
При роботі з сотрованими масивами при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 4,62 разів більше часу для виконання, що дещо більше за O(log10), але значно менше за O(10) при збільшенні кількості елементів масиву з 100 до 1000 потребує в 13,26 разів більше часу для виконання, що більше за O(10), але менше за O(10*log10).
З цих даних випливає найгірша часова складність алгоритму O(n*logn)

Алгоритм sorted() при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 8,93 разів більше часу для виконання, що відповідає приблизно O(10), при збільшенні кількості елементів масиву з 100 до 1000 потребує в 28 разів більше часу для виконання, що приблизно дорівнює O(10*log10).
При роботі з сотрованими масивами при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 4,62 разів більше часу для виконання, що дещо більше за O(log10), але значно менше за O(10) при збільшенні кількості елементів масиву з 100 до 1000 потребує в 13,26 разів більше часу для виконання, що більше за O(10), але менше за O(10*log10).
З цих даних випливає найгірша часова складність алгоритму O(nlogn)

Алгоритм сортування вставками при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 105 разів більше часу для виконання, що відповідає приблизно O(100), при збільшенні кількості елементів масиву з 100 до 1000 потребує в 119 разів більше часу для виконання, що приблизно дорівнює O(100).
При роботі з сотрованими масивами при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 11 разів більше часу для виконання, що відповідає O(10), при збільшенні кількості елементів масиву з 100 до 1000 потребує в 12 разів більше часу для виконання, що дещо більше за O(10), але менше за O(10log10).
З цих даних випливає найгірша часова складність алгоритму O(n2), але якщо елементи масиву частково або повністю вже відсортовані, то найкраща часова складність прямує до O(n)

Алгоритм сортування злиттям при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 23,13 разів більше часу для виконання, що відповідає приблизно O(10log10), при збільшенні кількості елементів масиву з 100 до 1000 потребує в 9,84 разів більше часу для виконання, що приблизно дорівнює O(10).
При роботі з сотрованими масивами при збільшенні кількості елементів масиву в 10 разів з 10 до 100 потребує в 20 разів більше часу для виконання, що менше за O(10log10), при збільшенні кількості елементів масиву з 100 до 1000 потребує в 10,3 разів більше часу для виконання, що відповідає O(10).
З цих даних випливає найгірша часова складність алгоритму O(nlogn), але якщо елементи масиву частково або повністю вже відсортовані, то найкраща часова складність прямує до O(n)

Найкращу абсолютну швидкодію показують вбудовані алгоритми sort() та sorted(). Час виконання менше щонайменше на порядок для будь-яких масивів порівняно з алгоритмами злиттям та вставками.

Найповільнішим є алгоритм сортування вставками при сортуванні масиву, елементи якого попередньо не відсортовані. Сортування масиву з 1000 чисел зайняло 44 секунди порівняно з 0.13 для вбудованих методів.
Але якщо масив попередньо відсортований, то найповільнішим виявився алгоритм сортування злиттям - сортування масиву з 1000 чисел зайняло 3,09 секунди порівняно з 0.16 - 0,19 для вбудованих методів.
